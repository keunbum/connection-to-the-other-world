# 04-3 Iterative 기반의 서버, 클라이언트 구현

이제 에코 서버와 에코 클라이언트를 구현해보고자 한다.

---

## Iterative 서버의 구현

**iterative**  
: 되풀이하는, 반복의; [컴퓨터](어떤 루프나 일련의 스텝 등을) 반복하는, (공식·조작법 따위가) 반복(적용)의, 되풀이의.

<img src="../../../img/Iterative%20%EC%84%9C%EB%B2%84%EC%9D%98%20%ED%95%A8%EC%88%98%20%ED%98%B8%EC%B6%9C%20%EC%88%9C%EC%84%9C.png" width="20%" height="20%">

위 흐름도에서 close(client)는 accept 함수 호출 과정에서 생성된 소켓을 대상으로 한다.

---

## Iterative 에코 서버, 에코 클라이언트

다음과 같은 조건을 만족하는 에코 서버/클라이언트 프로그램을 작성해보도록 한다.

* 서버는 한 순간에 하나의 클라이언트와 연결되어 에코 서비스를 제공한다.
* 서버는 총 다섯 개의 클라이언트에게 순차적으로 서비스를 제공하고 종료한다.
* 클라이언트는 프로그램 사용자로부터 문자열 데이터를 입력 받아서 서버에 전송한다.
* 서버는 전송 받은 문자열 데이터를 클라이언트에게 재전송한다. 즉, 에코 시킨다.
* 서버와 클라이언트 간 문자열 에코는 클라이언트가 Q를 입력할 때까지 계속한다.

---

## 에코 클라이언트의 문제점

(책에서는 예제를 보여주고 잘못된 점을 지적하며 알려주는데, 깃허브에는 책의 예제뿐만 아니라 내 방식대로 구현한 내 코드도 올림.  
책 내용을 일단 적어놓겠음.)

[echo_server.c](./echo_server.c)  
[echo_client.c](./echo_client.c)  
[my_echo_server.c](./my_echo_server.c)  
[my_echo_client.c](./my_echo_client.c)

위의 코드(책에 적힌 필자의 코드)는 다음과 같은 잘못된 가정이 존재한다.

    "read, write 함수가 호출될 때마다 문자열 단위로 실제 입출력이 이루어진다."

물론 write 함수를 호출할 때마다 하나의 문장을 전송하니, 이렇게 가정하는 것도 무리는 아니다. 하지만 TCP는 데이터의 경계가 존재하지 않는다고 했던 Chapter 02의 설명을 기억하는가? 위에서 구현한 클라이언트는 TCP 클라이언트이기 때문에 둘 이상의 write 함수호출로 전달된 문자열 정보가 묶여서 한번에 서버로 전송될 수 있다. 그리고 그러한 상황이 발생하면 클라이언트는 한번에 둘 이상의 문자열 정보를 서버로부터 되돌려 받아서, 원하는 결과를 얻지 못할 수 있다. 그리고 서버가 다음과 같이 판단하는 상황도 생각해봐야 한다.

    "문자열의 길이가 제법 긴 편이니, 문자열을 두 개의 패킷에 나눠서 보내야겠군!"

서버는 한번의 write 함수 호출로 데이터 전송을 명령했지만, 전송할 데이터의 크기가 크다면, 운영체제는 내부적으로 이를 여러 개의 조각으로 나눠서 클라이언트에게 전송할 수도 있는 일이다. 그리고 이 과정에서 데이터의 모든 조각이 클라이언트에게 전송되지 않았음에도 불구하고, 클라이언트는 read 함수를 호출할지도 모른다.  
이 모든 문제가 TCP의 데이터 전송특성에서 비롯된 것이다. 그렇다면 어떻게 이 문제를 해결해야 할까? 이에 대한 해답은 다음 Chapter에서 찾아보기로 하자.
