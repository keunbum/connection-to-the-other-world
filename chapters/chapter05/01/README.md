# 05-1 에코 클라이언트의 완변 구현!

---

## 에코 서버는 문제가 없고, 에코 클라이언트만 문제가 있나요?

문제는 에코 서버에 있지 않고, 에코 클라이언트에 있다.

에코 클라이언트는 문자열을 전송한다. 그것도 write 함수호출을 통해서 한방에 전송한다. 그리고 read 함수호출을 통해 자신이 전송한 데이터를 한방에 수신하기를 원하고 있다. 바로 이것이 문제이다.

    "결국엔 에코 클라이언트에게 문자열 데이터가 전부 전송되니까 기다리면 되겠네요. 시간 좀 지나서
    read 함수를 호출하면 한방에 문자열 데이터를 수신할 수 있는 것 맞죠?"

맞다. 시간이 좀 지나면 수신할 수 있다. 그런데 얼마나 기다려야 하겠는가? 이치에 맞는 클라이언트라면 문자열 데이터가 전송되었을 때 이를 모두 알맞게 읽어서 출력해야 한다.

---

## 에코 클라이언트의 해결책!

이 경우에는 해결이 쉽다. 클라이언트가 수신해야 할 데이터의 크기를 알고 있기 때문이다. 전송한 만큼 받으면 된다. 즉, 전송한 바이트 수만큼 수신할 때까지 read 함수를 반복하여 호출하면 된다.

(이걸 적용한 코드를 이미 [chapter04/03/](../../chapter04/03/)에서 작성함.)

---

## 에코 클라이언트의 이외의 경우에는? 어플리케이션 프로토콜의 정의

에코 클라이언트의 경우에는 수신할 데이터의 크기를 이전에 파악할 수 있지만, 이것이 불가능한 경우가 훨씬 많음을 인식해야 한다.
그렇다면 이렇게 수신할 데이터의 크기를 파악하는 것이 불가능한 경우에는 어떻게 데이터를 송수신 해야할까? 이러한 경우에 필요한 것이 바로 어플리케이션 프로토콜의 정의이다.  
데이터의 송수신 광정에서 데이터의 끝을 파악할 수 있는 약속(프로토콜)을 별도로 정의하여 데이터의 끝을 표현하거나, 송수신될 데이터의 크기를 미리 알려줘 그에 따른 대비가 가능해야 한다. 서버/클라이언트의 구현과정에서 이렇게 하나둘씩 만들어지는 약속을 모아 '어플리케이션' 프로토콜'이라 한다. 이렇듯 어플리케이션 프로토콜은 대단한 것이 아니다. 목적에 맞는 프로그램의 구현에 따라서 정의하게 되는 약속에 지나지 않는다.

그럼 어플리케이션 프로토콜의 정의를 경험하기 위해 프로그램 하나를 작성해 보자. 이 프로그램에서 서버는 클라이언트로부터 여러 개의 숫자와 연산자 정보를 전달받는다. 그러면 서버는 전달받은 숫자를 바탕으로 덧셈, 뺄셈, 또는 곱셈을 계산하여 그 결과를 클라이언트에게 전달한다.

예시

| 입력 | 출력 |
|---|---|
| 3 5 9 + | 3 + 5 + 9 = 17 |
| 3 5 9 - | 3 - 5 - 9 = -11 |
| 3 5 9 * | 3 * 5 * 9 = 135 |

(저자가 책에서 이렇게 말하고 있기에 직접 프로그램을 작성해보고자 한다.)

> 자! 그럼 이 정도 요구사항만 가지고 여러분이 직접 서버와 클라이언트를 구현해보기 바란다.
  세부적인 사항은 여러분들 나름대로 정의해 가면서 말이다.

(참고로 저자는 본 책의 끝 챕터(chapter25)에서 다음과 같은 말을 남겼는데,
이걸 읽으니 혼자서 만들어야 겠다는 마음이 더 드는.. 
꽤 긴데도 적어보는 그 내용..)

> ## 이걸 구현하려면 어떤 책을 봐야 할까요?
> 구현에 대한 경험이 부족하다면, 그만큼 책에 대한 의존도는 높아질 수밖에 없다. 그리고 이는 필자도 마찬가지이다.
  필자도 경험이 부족한 새로운 유형의 프로젝트를 시작할 때면, 관련 자료를 모으는 과정에서 국내외에 출간된 서적들도 조사를
  한다. 그러나 책을 통해서 구현에 대한 답을 찾지는 못한다. 이는 소프트웨어의 구현 결과물이 창의적인 창작의 결과물이기
  때문이다. 동일한 기능의 소프트웨어를 만들더라도 프로그래머에 따라서 구현방법에는 큰 차이를 보인다. 때문에 그 방법에 있어서
  정답이란 없다. 그리고 정답이 없는 것은 책을 통해서 정보를 얻기 힘들다. 그래서 여러분은 탄탄한 이론적 배경을 갖춰야 하고, 
  이를 바탕으로 창의적인 결과물을 만드는 연습을 할 필요가 있다.  
>
>  참고로 여러분이 간단한 온라인 전투 테트리스 게임을 개발해야 하고, 여러분 주변에는 도움을 받을 수 있는 선배 프로그래머가
   있다고 가정해보자. 그렇다면 다음과 같이 질문해선 안 된다.  
>
>       "온라인 전투 테트리스 게임을 구현하려고 하는데, 어떻게 진행을 해야 하나요? 어떤 책을 보면 될까요?"
>
> 답답한 마음은 이해를 하나, 이렇게 질문했을 때 돌아오는 답변은 여러분에게 별 도움이 되지 않는다(이렇게 질문하면 답변하는 사람도 어떻게 답변을 해야 할지 잘 모른다). 때문에 질문의 범위는 다음과 같이 최소화해야 하고, 보다 구체적이어야 한다.
>
>       "온라인 전투 테트리스 게임을 구현하려고 하는데요. 상대방의 테트리스 블록 정보를 어떻게 전송하는 것이 가장 좋을까요?
>        한 가지 방법을 제가 구상해 봤는데요. 이게 타당한 방법이 될 수 있을까요?"
>
> 질문의 범위는 이보다 더 최소화할수록, 보다 더 구체적일수록 좋다. 한 번 질문할 것을 서너 번에 나눠서 질문한다고
  생각하면 되지 않겠는가? 그렇게 되면 여러분은 질문의 과정에서 더 많이 생각하게 되고, 더 많은 것을 이해할 수 있을 것이다.

(그래서 내 나름대로 구현해보고자 한다.  
아래부터는 내가 쓴 글)

> 프로그램을 작성하기 앞서, 요구 사항 분석부터 해보자.  
> 우선 원하는 실행 결과는 아래와 같다. (더 근사한 계산 서버를 작성할 수도 있겠지만 시간 관계 상 간단하게 구현하자..)
>
> ```bash
>$ ./my_op_client 9130
>숫자들을 입력하세요 (q to quit): 3 5 9 10
>연산자를 입력하세요 (q to quit): +
>3 + 5 + 9 + 10 = 27
>숫자들을 입력하세요 (q to quit): q
>$ 
>```
>
> ### 입출력 요구 사항
>
> #### 입력
>
> * 한 줄당 입력되는 바이트 수는 최대 127이다.
> * 수는 int범위의 음이 아닌 십진법 정수이다.
> * 입력의 시작과 끝에는 공백이 없고, 숫자들은 하나의 공백을 두고 주어진다.
> * 연산자는 +, -, * 중 하나가 주어진다.
> * 계산 과정이나 결과에서 나오는 값은 항상 int 범위이다.
> * 단, 사용자가 ```숫자들을 입력하세요 (q to quit)``` 나 ```연산자를 입력하세요 (q to quit):```에서 **q**나 **Q**를 입력하면 프로그램을 종료한다.
> * 피연산자는 항상 2개 이상 주어진다.
> 
> #### 출력
>
> * 계산 결과뿐만 아니라 수식까지 완성하여 출력한다. (숫자와 기호 사이를 하나의 공백으로 구분)
>   ```bash
>   3 + 5 + 9 + 10 = 27
>   ```
>
> 이를 바탕으로 어플리케이션 프로토콜도 정의해보자.
>
> --- 
> 
> ### 어플리케이션 프로토콜
> 
> #### (1) 클라이언트
> 
> * 사용자로부터 숫자들과 연산자를 입력받아 서버에 공백으로 구분하여 보낸다.
>   ```txt
>   3 5 9 10 +
>   ```
> * 사용자가 프로그램을 종료하면 close를 통해 소켓을 닫는다. 상대 소켓에 EOF가 전송된다.
>
> #### (2) 서버
> 
> * 편의상 서버는 N번의 루프를 수행하는 서버라 가정한다. (즉 N명의 클라이언트와 연결 가능)
> * 클라이언트로부터 read의 반환 값이 0이 될 때까지(상대가 EOF를 전송할 때까지) 메시지를 입력 받는다.
> * (잠깐만 근데.. 각각의 계산식을 어떻게 구분하지?)  
>   => 각각의 요청을 구분하는 기준은 연산자 기호이므로 이를 기준으로 잘라 처리한다. (즉 연산자를 만날 때마다 초기화)
> * 결과를 계산하여 다음과 같은 포맷으로 클라이언트에 전송한다. (뒤에 공백 하나 있음)
>   ```txt
>   27 
>   ```
> * 이렇게 결과값 뒤에 공백을 두고 보내야 클라이언트에서 각 결괏값을 구분할 수 있다.
> * EOF를 받으면 close를 호출하여 해당 클라이언트와의 연결을 종료한다.
>
> --- 
>
> ### 프로그래밍 요구 사항
> 
> 이건 친구들이 한 [우테코 프리코스](https://github.com/woowacourse-precourse/java-lotto#-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD)(나는 안함)에서 알게된 내용인데 요런 조건도 적용하면 재밌을 듯.  
> (백준 풀 때와는 다른.. 현업스러운(?) 코딩 컨벤션)
> * indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
>   * 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
>   * 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.
> * 3항 연산자를 쓰지 않는다.
> * 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
>   * 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
> * else 예약어를 쓰지 않는다.
>   * 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
>   * else를 쓰지 말라고 하니 switch/case로 구현하는 경우가 있는데 switch/case도 허용하지 않는다.

---  


## 계산기 서버, 클라이언트의 예
    
    